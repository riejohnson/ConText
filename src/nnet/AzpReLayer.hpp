/* * * * *
 *  AzpReLayer.hpp
 *  Copyright (C) 2016,2017 Rie Johnson
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * * * * */
#ifndef _AZP_RE_LAYER_HPP_
#define _AZP_RE_LAYER_HPP_

#include "AzParam.hpp"
#include "AzPmat.hpp"
#include "AzpCompoSet_.hpp"
#include "AzpData_.hpp"

/***
 *  Class hierarchy: 
 *  AzpReLayer_ 
 *          AzpReLayer_Wei_ (Layer with weights that can take sparse input) 
 *                  AzpReLayer_LSTM (LSTM)
 *                          AzpReLayer_LstmF (forward-LSTM) 
 *                          AzpReLayer_LstmB (backward-LSTM)
 *                  AzpReLayer_Fc ("Weight+": Weighting.  Other things can also be done optionally)
 *                          AzpRelayer_FcS ("WeightS+": "Weight+" plus one or more side layer attached)
 *          AzpReLayer_DenseWei_ (Layer with weights that can only take dense input. 
                                  compared with AzpReLayer_Wei_, more restricted but simpler) 
                    AzpReLayer_DenseWei (Weight) 
 *          AzpReLayer_NoWei_ (Layer without weights)
 *                  AzpReLayer_Patch (Make 1-dim patches, first half of convolution layer) 
 *                  AzpReLayer_Pooling (Pooling)
 *                  AzpReLayer_Act (Activation)  
 *                  AzpReLayer_Dropout (Dropout)  
 *                  AzpReLayer_Noop (Do nothing)   
 *                  AzpReLayer_PassLast (Pass the last time step output to upper) 
 *          AzpReLayer_ComboH (Combination of multiple layers, 'H' for horizontal)
 *                  AzpReLayer_Lstm2 (forward-LSTM+backward-LSTM)
 *          AzpReLayer_Side ('side' layer used to produce additional input, 
 *                           typically generated by tv-embedding training with unlabeled data)
***/

/*------------------------------------------------------------*/  
#define AzpReLayer_Type_Fc "Weight+"
#define AzpReLayer_Type_FcS "WeightS+"
#define AzpReLayer_Type_DenWei "DenWei"
#define AzpReLayer_Type_LstmF "LstmF"
#define AzpReLayer_Type_LstmB "LstmB"
#define AzpReLayer_Type_Lstm2 "Lstm2"
#define AzpReLayer_Type_PassLast "PassLast"
#define AzpReLayer_Type_Pooling "Pooling"
#define AzpReLayer_Type_Patch "Patch"
#define AzpReLayer_Type_Noop "Noop"
#define AzpReLayer_Type_Dropout "Dropout"
#define AzpReLayer_Type_Act "Act"
/*------------------------------------------------------------*/ 
/* for compatibility */
#define AzpReLayer_Type_Fc_ "Weight"
#define AzpReLayer_Type_FcS_ "WeightSide" 
/*------------------------------------------------------------*/ 

class AzpReUpperLayer_ { /* interface */
public: 
  virtual void get_ld(int id, AzPmatVar &mv_lossd_a, bool do_x2=false) const = 0; 
};
class AzpReLayer_Param {   
public:
  bool is_spa; 
  int lno, cc, class_num, cc2; /* "cc" means # of feature maps for historical reasons ... */
  AzIntArr ia_dscc; 
  AzpReLayer_Param() : is_spa(false), lno(-1), cc(-1), cc2(-1), class_num(-1) {}
  AzpReLayer_Param(const AzpData_tmpl_ *data) : is_spa(false), lno(-1), cc(-1), cc2(-1), class_num(-1) { reset_dscc(data); }
  AzpReLayer_Param(const AzpData_tmpl_ *data, int _cc, bool _is_spa, int _lno, int _class_num=-1) {
    cc=_cc; is_spa=_is_spa; lno=_lno; class_num=_class_num; 
    reset_dscc(data); 
  }
  void reset_dscc(const AzpData_tmpl_ *data) {
    AzX::throw_if_null(data, "AzpReLayer_Param::reset_dscc", "data"); 
    ia_dscc.reset(); 
    for (int dx = 0; dx < data->datasetNum(); ++dx) ia_dscc.put(data->xdim(dx)); 
  }
};     
                
/*---  base class  ---*/
#define _ReLay_top_   "top_"
class AzpReLayer_ : public virtual /* implements */ AzpReUpperLayer_ {
protected:
  AzBytArr s_nm;   
  const AzpReUpperLayer_ *upper;
  AzOut out; 
  AzBytArr s_nicknm; /* nickname 12/10/2016 */
  int layer_no; 
  
  const AzPfx *sv_pfx; bool sv_do_override_lno; /* used by AzpReLayer_Lay */
  
  static const int version = 0; 
/*  static const int reserved_len = 128; */
  static const int reserved_len = 127; /* for writing s_nicknm: 7/1/2017 */
  
  #define _ReLayMarker_ "ReLay"
  #define _ReLayMarkerLen_ 5 
public:
  AzpReLayer_() : upper(NULL), out(log_out), layer_no(-1), sv_pfx(NULL), sv_do_override_lno(false) {}
  virtual void reset(const AzpCompoSet_ *cset) = 0; 
  virtual ~AzpReLayer_() {} 
#if 0   
  /*---  old format  ---*/
  virtual void write(AzFile *file) const { writenm(file); _write(file); }
  virtual void read(AzFile *file)  { readnm(file);  _read(file);  }
#else    
  /*---  since 6/xx/2017  ---*/
  virtual void write(AzFile *file) const {
    file->writeInt(_ReLayMarkerLen_); file->writeBytes(_ReLayMarker_, _ReLayMarkerLen_); 
    AzTools::write_header(file, version, reserved_len); 
    bool do_nicknm = true; file->writeBool(do_nicknm); /* 7/1/2017 */
    if (do_nicknm) s_nicknm.write(file); /* 7/1/2017 */
    file->writeInt(layer_no); 
    writenm(file); _write(file);  
  }
  virtual bool is_there_hdr(AzFile *file) {
    if (file->readInt() != _ReLayMarkerLen_) return false; 
    AzByte marker[_ReLayMarkerLen_]; file->readBytes(marker, _ReLayMarkerLen_); 
    return (memcmp(marker, _ReLayMarker_, _ReLayMarkerLen_) == 0);     
  }
  virtual void read(AzFile *file) {
    AZint8 offs = file->tell(); 
    if (!is_there_hdr(file)) file->seek(offs); /* 6/xx/2017: for compatibility */
    else {   
      AzTools::read_header(file, reserved_len);
      bool do_nicknm = file->readBool(); /* 7/1/2017: for compatibility */
      if (do_nicknm) s_nicknm.read(file); /* 7/1/2017 */
      layer_no = file->readInt();     
    }
    readnm(file); _read(file);     
  }
#endif   
  virtual void write(const char *fn) const { AzFile::write(fn, this); }
  virtual void read(const char *fn) { AzFile::read(fn, this); }
  virtual int coldstart(const AzOut &_out, const AzpReUpperLayer_ *_upper, AzParam &azp, const AzpReLayer_Param &pp, 
                        const AzPfx *_pfx=NULL) /* used by ComboH */ {
    out=_out; upper=_upper; 
    layer_no = pp.lno; 
    sv_pfx = _pfx; /* used by Lay */
    AzPfx pfx(_pfx); gen_prefix(layer_no, pfx); 
    reset_nickname(azp, pfx);     
    show_coldstart();    
    return setup(azp, pp, pfx, false, false); 
  }  
  virtual int warmstart(const AzOut &_out, const AzpReUpperLayer_ *_upper, AzParam &azp, const AzpReLayer_Param &pp,
                        bool for_testonly, bool _do_override_lno=false, const AzPfx *_pfx=NULL) {                      
    out=_out; upper=_upper; 
    AzX::throw_if(!_do_override_lno && layer_no != pp.lno, "AzpReLayer_::warmstart", "layer# conflict"); 
    layer_no = pp.lno; 
    AzPfx pfx(_pfx); gen_prefix(layer_no, pfx);     
    sv_pfx = _pfx; sv_do_override_lno=_do_override_lno; /* used by Lay and ComboH */
    show_warmstart();
    bool is_warmstart = true; 
    return setup(azp, pp, pfx, is_warmstart, for_testonly); 
  }
  virtual void v2_setup() {} /* To match v2.  Override this as needed. */
  virtual void reset_upper(const AzpReUpperLayer_ *_upper) {
    AzX::throw_if(upper == NULL && _upper != NULL || upper != NULL && _upper == NULL, "AzpReLayer_::reset_upper", 
                  "Illegal attempt"); 
    upper = _upper; 
  }  
  
  /*========================================*/  
  virtual void upward(bool is_test, const AzDataArr<AzpDataVar_X> &data, AzPmatVar &mv_out, const AzPmatVar *mv2=NULL) = 0; 
  virtual void upward(bool is_test, const AzPmatVar &mv_below, AzPmatVar &mv_out, const AzPmatVar *mv2=NULL) = 0; 
  virtual void downward(const AzPmatVar &mv_loss_deriv, bool dont_update=false, bool dont_release_sv=false) = 0; 
  virtual int id() const { return layer_no; }  
  virtual void flushDelta() = 0; 
  virtual void end_of_epoch() = 0; 
  virtual void show_stat(AzBytArr &s) const = 0; 
  virtual void multiply_to_stepsize(double coeff, const AzOut *out) = 0; 
  virtual double regloss(double *out_iniloss=NULL) const = 0;  
  virtual bool is_top() const { return (upper == NULL); }
  /*========================================*/  
  virtual void upward2(const AzPmatVar &, AzPmatVar &, bool do_update=false) { /* override this as needed */
    AzX::no_support(true, "AzpReLayer_::upward2", "upward2"); 
  }  
  /*========================================*/   
  virtual const AzBytArr &nm() const { return s_nm; }
  virtual bool doing_adv() const { return false; }
  virtual void set_adv() {}
  
  virtual AzpLm *linmod_u() { /* AzpReLayer_Fc should override this.  This is for "do_partial".  Use with caution.  */
    AzX::throw_if(true, "AzpReLayer_::linmod_u", "no lm in this layer"); return NULL; 
  }

  /*------------------------------------------------------------*/ 
  int coldstart(const AzBytArr *s_lay_fn, const AzOut &_out, const AzpReUpperLayer_ *_upper, AzParam &azp, 
                const AzpReLayer_Param &pp, const AzPfx *_pfx=NULL) {
    if (s_lay_fn == NULL || s_lay_fn->length() <= 0) {
      return coldstart(_out, _upper, azp, pp, _pfx); 
    }
    else {
      AzPrint::writeln(_out, "Reading ", s_lay_fn->c_str(), " ... "); 
      read(s_lay_fn->c_str()); 
      bool for_testonly = false, do_override_lno = true; 
      return warmstart(_out, _upper, azp, pp, for_testonly, do_override_lno, _pfx); 
    }
  }
  
  static void write_pmat(AzFile *file, const AzPmat &m, const char *str) {
    AzBytArr s(str); s.write(file); m.write(file); 
  }
  static void write_lm(AzFile *file, const AzpLm *lm, const char *str) {
    AzX::throw_if_null(lm, "AzpReLayer_::write_lm", "null lm"); 
    AzBytArr s(str); s.write(file); lm->write(file); 
  }  

  /*--- call this only for a bottom layer ---*/
  virtual void check_word_mapping(const AzpData_tmpl_ *data) {} /* default: do nothing */
  virtual void write_word_mapping(const char *fn) const { /* override to write word mapping */
    AzBytArr s("This layer is not associated with word mapping: "); s << s_nm; 
    AzX::throw_if(true, AzInputError, "AzpReLayer_::write_word_mapping", s.c_str()); 
  }
  virtual void release_ld() {} /* override this */
  virtual void release_sv() {} /* override this */  
  
protected:   
  /*=======================================*/
  virtual int setup(AzParam &azp, const AzpReLayer_Param &pp, const AzPfx &pfx, 
                    bool is_warmstart, bool for_testonly) = 0;     
  virtual void _write(AzFile *file) const = 0; 
  virtual void _read(AzFile *file) = 0; 
  /*=======================================*/ 
  virtual void reset_nickname(AzParam &azp, const AzPfx &pfx) {
    s_nicknm.reset(); 
    #define kw_nicknm "name="    
    azp.reset_prefix(pfx.pfx()); azp.vStr(kw_nicknm, &s_nicknm); azp.reset_prefix();     
  }
  virtual void show_start(int lno, bool is_warmstart) const {  
    AzBytArr s("Layer#"); s << lno; 
    if (s_nicknm.length() > 0) s << " [" << s_nicknm << "]"; 
    if (is_warmstart) AzPrint::writeln(out, s, " -----  Warm-starting ", s_nm.c_str(), "  -----"); 
    else              AzPrint::writeln(out, s, " -----  Cold-starting ", s_nm.c_str(), "  -----"); 
  }
  virtual void show_coldstart() const { show_start(layer_no, false); }
  virtual void show_warmstart() const { show_start(layer_no, true); }

  void gen_prefix(int layer_no, AzPfx &pfx) const; 
  void no_support2(const AzPmatVar *mv2, const char *eyec) const { AzX::no_support((mv2 != NULL), eyec, "side layer"); } 
  virtual void writenm(AzFile *file) const { s_nm.write(file); }
  virtual void readnm(AzFile *file) {
    AzBytArr snm; snm.read(file);       
    AzBytArr s("Expected layer type: "); s << s_nm << ", layer type in the file: " << snm; 
    if (!snm.equals(s_nm.c_str())) AzPrint::writeln(out, "WARNING: ", s);  
  } 
  virtual void show_weight_dim(const AzpWeight_ *wei, const char *header="") const; 
  virtual void no_support_sparse(const AzpReLayer_Param &pp) const {
    if (pp.is_spa) {
      AzBytArr s("Sparse input to a "); s << s_nm << " layer"; 
      if (s_nicknm.length() > 0) s << " (" << s_nicknm << ") ";
      s << ".";       
      AzX::no_support(pp.is_spa, "AzpReLayer_::no_support_sparse", s.c_str()); 
    }
  }
};

/*------------------------------------------------------------*/ 
class AzpReLayerWei_Param {
protected: 
  static const int version = 0; 
/*  static const int reserved_len = 64; */
/*  static const int reserved_len = 62; /* 12/12/2015: do_bn_vx, do_bn_o */
  static const int reserved_len = 58; /* 1/17/2016: dsno */
public: 
  AzBytArr s_iw_fn, s_iw_wordmap_fn;  /* don't save these */
  double iw_coeff; 
  int nodes, dsno; 

  AzpReLayerWei_Param() : iw_coeff(1), nodes(-1), dsno(-1) {}

  virtual void resetParam(const AzOut &out, AzParam &azp, const AzPfx &pfx, bool is_top=false, bool is_warmstart=false) {
    for (int px=0; px<pfx.size(); ++px) resetParam(azp, pfx[px], is_top, is_warmstart); 
    checkParam(pfx.pfx(), is_top); 
    printParam(out, pfx.pfx(), is_top); 
  }                         
  /*------------------------------------------------------------*/  
  #define kw_nodes "nodes="
  #define kw_iw_fn "weight_fn="
  #define kw_iw_wordmap_fn "weight_wordmap_fn="  
  #define kw_iw_coeff "weight_coeff="
  #define kw_dsno "dsno="
  /*------------------------------------------------------------*/  
  virtual void resetParam(AzParam &azp, const char *pfx, bool is_top, bool is_warmstart=false) {     
    azp.reset_prefix(pfx); 
    if (!is_top && !is_warmstart) azp.vInt(kw_nodes, &nodes);  
    if (!is_warmstart) {     
      azp.vStr(kw_iw_fn, &s_iw_fn); 
      if (s_iw_fn.length() > 0) azp.vStr(kw_iw_wordmap_fn, &s_iw_wordmap_fn); 
      if (s_iw_fn.length() > 0) azp.vFloat(kw_iw_coeff, &iw_coeff); 
    }
    if (!is_top) azp.vInt(kw_dsno, &dsno); /* 1/24/2016: allow overwrite as it may be a side */
    azp.reset_prefix();        
  }
  virtual void checkParam(const char *pfx, bool is_top) const {
    const char *eyec = "AzpReLayerWei_Param::checkParam"; 
    if (!is_top) AzXi::throw_if_nonpositive(nodes, eyec, kw_nodes, pfx); 
  }
  virtual void printParam(const AzOut &out, const char *pfx, bool is_top=false) const {
    if (out.isNull()) return; 
    AzPrint o(out); 
    o.reset_prefix(pfx);    
    if (!is_top) o.printV(kw_nodes, nodes);      
    if (!is_top) o.printV(kw_dsno, dsno); 
    o.printV_if_not_empty(kw_iw_fn, s_iw_fn); 
    o.printV_if_not_empty(kw_iw_wordmap_fn, s_iw_wordmap_fn); 
    if (s_iw_fn.length() > 0) o.printV(kw_iw_coeff, iw_coeff); 
    o.printEnd(); 
  }   
  
  virtual void write(AzFile *file) const {
    AzTools::write_header(file, version, reserved_len); 
    file->writeInt(dsno); 
    file->writeBool(false); file->writeBool(false); /* for compatibility */
    file->writeInt(nodes); 
  }
  virtual void read(AzFile *file) {
    AzTools::read_header(file, reserved_len);
    dsno = file->readInt(); 
    file->readBool(); file->readBool(); /* for compatibility */
    nodes = file->readInt(); 
  } 
}; 

/*------------------------------------------------------------*/ 
class AzpReLayer_Wei_ : public virtual AzpReLayer_ {
protected:   
  AzpLayerCompoPtrs cs; 

  AzObjPtrArr<AzpWeight_> wei;
  AzpWeight_ *wei_x, *wei_x2; 
  AzObjPtrArr<AzpActiv_> act; 
  AzpActiv_ *act_x; 

  AzpReLayerWei_Param lap; 

  AzPmatVar mv_sv_x, mv_sv_x2; 
  AzPmatSpaVar msv_sv_x; 
  AzPmatVar mv_ld_x; 

  AzDicc dicc; /* for word mapping check */
    
  virtual void reset() {
    wei.free(); wei_x = NULL; wei_x2 = NULL; 
    act.free(); act_x = NULL; 
    upper = NULL; 
    layer_no = -1; 
    mv_sv_x.destroy(); mv_sv_x2.destroy(); 
    msv_sv_x.destroy(); 
    mv_ld_x.destroy();     
  }
  
  static const int version = 0; 
/*  static const int reserved_len = 128; */
  static const int reserved_len = 127; /* 1/14/2016: for do_dicc (word mapping) */
 
public:
  AzpReLayer_Wei_() : wei_x(NULL), wei_x2(NULL), act_x(NULL) {}
  virtual ~AzpReLayer_Wei_() {}
  
  virtual void reset(const AzpCompoSet_ *cset) {
    reset(); cs.reset(cset); 
    init_wei(); init_act(); 
    check_if_ready("AzpReLayer_Wei_::reset"); 
  }

  virtual void check_if_ready(const char *msg) const {
    cs.check_if_ready(msg);  
    wei.check_if_ready(msg, "wei"); act.check_if_ready(msg, "act"); 
    AzX::throw_if_null(wei_x, msg, "wei_x"); AzX::throw_if_null(act_x, msg, "act_x"); 
  }
  
  virtual void _write(AzFile *file) const {
    check_if_ready("AzpReLayer_Wei_::_write"); 
    AzTools::write_header(file, version, reserved_len); 
    bool do_dicc = true; file->writeBool(do_dicc); if (do_dicc) dicc.write(file);  
    file->writeInt(layer_no); /* for compatibility */
    lap.write(file); 
    for (int ix = 0; ix < wei.size(); ++ix) wei[ix]->write(file); 
    for (int ix = 0; ix < act.size(); ++ix) act[ix]->write(file); 
    cs.write(file); 
  }
  virtual void _read(AzFile *file) {
    cs.check_if_ready("AzpReLayer_Wei_::_read"); 
    AzTools::read_header(file, reserved_len);
    dicc.reset(); bool do_dicc = file->readBool(); if (do_dicc) dicc.read(file); 
    layer_no = file->readInt(); /* for compatibility */
    lap.read(file); 
    for (int ix = 0; ix < wei.size(); ++ix) wei(ix)->read(file); 
    for (int ix = 0; ix < act.size(); ++ix) act(ix)->read(file); 
    cs.read(file); 
  }
  
  virtual void upward(bool is_test, const AzDataArr<AzpDataVar_X> &dataarr, AzPmatVar &mv_out, const AzPmatVar *mv2=NULL);         
  virtual void upward(bool is_test, const AzPmatVar &mv_below, AzPmatVar &mv_out, const AzPmatVar *mv2=NULL); 
  virtual void downward(const AzPmatVar &mv_loss_deriv, bool dont_update=false, bool dont_release_sv=false); 
  virtual void flushDelta() { for (int i=0;i<wei.size();++i) wei(i)->flushDelta(); }
  virtual void end_of_epoch() { for (int i=0;i<wei.size();++i)wei(i)->end_of_epoch(); }  
  virtual void show_stat(AzBytArr &s) const { 
    for (int i=0;i<wei.size();++i) wei[i]->show_stat(s); 
  }
  virtual void multiply_to_stepsize(double coeff, const AzOut *out) { 
    for (int i=0;i<wei.size();++i) wei(i)->multiply_to_stepsize(coeff, out); 
  }  
  virtual double regloss(double *out_iniloss=NULL) const { double val=0; for (int i=0;i<wei.size();++i) val+= wei[i]->regloss(out_iniloss); return val;}
  
  virtual void get_ld(int id, AzPmatVar &mv_lossd_a, bool do_x2=false) const; 

  void init_x_weights(); 
  template <class M>  /* M: AzPmatVar | AzPmatSpaVar */
  static void set_order(const M &mv_below, int patch, int stride, bool do_backward, 
                        AzDataArr<AzIntArr> &oaia_inp, AzDataArr<AzIntArr> *oaia_out=NULL, bool do_align_to_end=false); 

  /*--- call this only for a bottom layer ---*/
  virtual void check_word_mapping(const AzpData_tmpl_ *data); 
  virtual void write_word_mapping(const char *fn) const { dicc.writeText(fn); }
  
  /*---  to save memory  ---*/
  virtual void release_sv() {
    msv_sv_x.reset(); mv_sv_x.reset(); mv_sv_x2.reset();     
  }
  virtual void release_ld() { 
    mv_ld_x.destroy(); 
    for (int ix=0;ix<act.size();++ix) act(ix)->release_ld(); 
  }  
  
protected:  
  virtual int setup(AzParam &azp, const AzpReLayer_Param &pp, const AzPfx &pfx, bool is_warmstart, bool for_testonly); 
  /*=========================================*/
  virtual bool is_re() const = 0;  /* recurrent? */
  virtual int wei_setup(AzParam &azp, const AzpReLayer_Param &pp, const AzPfx &pfx, bool is_warmstart, bool for_testonly) = 0; 
  virtual void wei_upward_dense(bool is_test, const AzPmatVar &mv_below, AzPmatVar &m_out, const AzPmatVar *mv2) = 0; 
  virtual void wei_upward_sparse(bool is_test, const AzPmatSpaVar &msv_below, AzPmatVar &m_out, const AzPmatVar *mv2) = 0;  
  virtual void wei_downward(bool) = 0; /* ld is set to mv_ld_x; for speeding up FC */
  virtual void wei_downward(const AzPmatVar &, bool) = 0; /* ld is passed as an argument; for LSTM */
  /*=========================================*/
                     
  virtual void check_dropout(const AzpReLayer_Param &pp, const char *eyec) const; 
  virtual void init_wei() {
    cs.check_if_ready("AzpReLayer_Wei_::init_wei"); 
    wei.free_alloc(1); 
    wei.set(0, cs.weight->clone()); 
    wei_x = wei(0);
  }
  virtual void init_act() {
    cs.check_if_ready("AzpReLayer_Wei_::init_act");     
    act.free_alloc(1); 
    act.set(0, cs.activ->clone()); 
    act_x = act(0); 
  }  
  virtual void save_input(bool is_test, const AzPmatVar &mv, const AzPmatVar *mv2=NULL); 
  virtual void save_input(bool is_test, const AzPmatSpaVar &msv, const AzPmatVar *mv2=NULL); 
  static void pass_up(const AzPmat &m_curr, AzPmat &m_next, int next_cnum); 
  static void pass_down(const AzPmat &m_next, AzPmat &m_curr);

  void reset_external_dic(const AzBytArr &s_fn);  
}; 

/*---  fully-connected layer or second-half of convolution layer  ---*/
class AzpReLayer_Fc : public virtual AzpReLayer_Wei_ {
protected: 
  static const int version = 0; 
  static const int reserved_len = 64; 
public:
  AzpReLayer_Fc() { s_nm.reset(AzpReLayer_Type_Fc); } 
  virtual ~AzpReLayer_Fc() {}
  
  virtual void _write(AzFile *file) const {
    AzpReLayer_Wei_::_write(file); 
    AzTools::write_header(file, version, reserved_len); 
  }
  virtual void _read(AzFile *file) {
    AzpReLayer_Wei_::_read(file); 
    AzTools::read_header(file, reserved_len);
  }  
  virtual AzpLm *linmod_u() { /* use this with a lot of caution! */
    AzX::throw_if_null(wei_x, "AzpReLayer_Fc::linmod_u", "wei_x"); 
    return wei_x->linmod_u();
  }
  void migrate(const char *inp_fn, const char *out_fn, bool is_lay0) { 
    AzFile ifile(inp_fn); ifile.open("rb"); 
    migrate(&ifile, is_lay0); 
    AzFile::write(out_fn, this);  
  }
  
protected:  
  bool is_re() const { return false; }
  virtual int wei_setup(AzParam &azp, const AzpReLayer_Param &pp, const AzPfx &pfx, bool is_warmstart, bool for_testonly); 
  virtual void wei_upward_dense(bool is_test, const AzPmatVar &mi, AzPmatVar &mo, const AzPmatVar *mv2) { 
    no_support2(mv2, "AzpReLayer_Fc::wei_upward_dense"); 
    _upward(is_test,mi,mo); 
  }
  virtual void wei_upward_sparse(bool is_test, const AzPmatSpaVar &mi, AzPmatVar &mo, const AzPmatVar *mv2) { 
    no_support2(mv2, "AzpReLayer_Fc::wei_upward_sparse"); 
    _upward(is_test,mi,mo); 
  }
  template <class M> void _upward(bool is_test, const M &mv_below, AzPmatVar &m_out);    
  virtual void wei_downward(bool dont_update); 
  virtual void wei_downward(const AzPmatVar &mv, bool dont_update) { /* this should not be called, though */
    mv_ld_x.set(&mv); wei_downward(dont_update); 
  }
  void migrate(AzFile *file, bool is_lay0); /* from AzpLayer */
}; 

/*---  FC layer with a side layer attached  ---*/
class AzpReLayer_FcS : public virtual AzpReLayer_Fc {
protected: 
  bool x2_needs_init; /* for compatibility */
public:
  AzpReLayer_FcS() : x2_needs_init(false) { s_nm.reset(AzpReLayer_Type_FcS); } 
  virtual ~AzpReLayer_FcS() {}
protected:  
  virtual void init_wei() {
    cs.check_if_ready("AzpReLayer_FcS::init_wei"); 
    wei.free_alloc(2); 
    wei.set(0, cs.weight->clone()); wei_x = wei(0); 
    wei.set(1, cs.weight->clone()); wei_x2 = wei(1);     
  }
  virtual int wei_setup(AzParam &azp, const AzpReLayer_Param &pp, const AzPfx &pfx, bool is_warmstart, bool for_testonly);   
  virtual void v2_setup(); /* To match v2 */
  virtual void wei_upward_dense(bool is_test, const AzPmatVar &mi, AzPmatVar &mo, const AzPmatVar *mv2) { 
    _upward(is_test,mi,mo,mv2); 
  }
  virtual void wei_upward_sparse(bool is_test, const AzPmatSpaVar &mi, AzPmatVar &mo, const AzPmatVar *mv2) { 
    _upward(is_test,mi,mo,mv2); 
  }
  template <class M> void _upward(bool is_test, const M &mv_below, AzPmatVar &m_out, const AzPmatVar *mv2=NULL);    
  virtual void wei_downward(bool dont_update); 
}; 

/*---  work area for a recurrent layer  ---*/
class AzpReLayer_Wei_Work /* for each position */ {
protected:
  AzIntArr ia_icols;     /* column id's of the input matrix */
  AzIntArr ia_ocols;     /* column id's of the output matrix */
public:
  void reset() { ia_icols.reset(); ia_ocols.reset(); }
  void set_cols(int pos, const AzDataArr<AzIntArr> &aia_inp, const AzDataArr<AzIntArr> *aia_out=NULL) {
    const char *eyec = "AzpReLayer_Wei_Work::set_cols"; 
    ia_icols.reset(aia_inp[pos]); 
    if (aia_out == NULL || aia_out->size() <= 0) ia_ocols.reset(); 
    else {
      const AzIntArr *ia_out = (*aia_out)[pos]; 
      AzX::throw_if(ia_icols.size() != ia_out->size(), eyec, "size conflict"); 
      ia_ocols.reset(ia_out); 
    }
  }
  virtual ~AzpReLayer_Wei_Work() {}
  int colNum() const { return ia_icols.size(); }
  const AzIntArr &icols() const { return ia_icols; }
  const AzIntArr &ocols() const { return (ia_ocols.size()>0) ? ia_ocols : ia_icols; }
};

/*---  Experimental; An attempt to reduce frequency of host-to-device copy  ---*/
class AzpReLayer_Wei_InOut {
protected:
  AzPintArr2v pia2v_i;     /* column id's of the input matrix */
  AzPintArr2v pia2v_o;     /* column id's of the output matrix */
public:
  bool on() const { return (pia2v_i.size() > 0); }
  void reset() { pia2v_i.reset(); pia2v_o.reset(); }
  void reset(const AzDataArr<AzIntArr> &aia_inp, const AzDataArr<AzIntArr> *aia_out=NULL) {
    const char *eyec = "AzpReLayer_Wei_InOut::set_cols"; 
    pia2v_i.reset(aia_inp); 
    if (aia_out == NULL || aia_out->size() <= 0) pia2v_o.reset(); 
    else {
      pia2v_o.reset(*aia_out); 
      for (int ix = 0; ix < pia2v_i.size(); ++ix) {
        AzX::throw_if((pia2v_i.length(ix) !=  pia2v_o.length(ix)), eyec, "length conflict"); 
      }
    }
  }
  virtual ~AzpReLayer_Wei_InOut() {}
  int colNum(int ix) const { check_idx(ix, "colNum"); return pia2v_i.length(ix); }
  const AzPintArr2v &icols() const { return pia2v_i; }
  const AzPintArr2v &ocols() const { return (pia2v_o.size()>0) ? pia2v_o : pia2v_i; }
protected:
  void check_idx(int ix, const char *msg) const {
    AzX::throw_if((ix < 0 || ix >= pia2v_i.size()), "AzpReLayer_Wei_InOut::check_idx", msg); 
  }  
};

/*------------------------------------------------------------*/  
class AzpReLayer_LSTM_Param {
protected: 
  static const int version = 0; 
  static const int reserved_len = 64; 
  int chopover; 
public: 
  bool do_i, do_f, do_o;
  int patch, stride; 
  bool do_test_with_patch; 
  int bprop_max; 
  bool do_align_to_end; 
  bool do_stat; 
  bool do_less_traffic;  /* reduce host-device traffic: an attempt to speed up */
  
  AzpReLayer_LSTM_Param() : do_i(true), do_f(true), do_o(true), patch(-1), chopover(-1), stride(-1), bprop_max(-1),  
                            do_test_with_patch(false), do_align_to_end(false), do_stat(false), 
                            do_less_traffic(false) {}                    
  void resetParam(const AzOut &out, AzParam &azp, const AzPfx &pfx, bool is_warmstart=false) {
    for (int px=0; px<pfx.size(); ++px) resetParam(azp, pfx[px], is_warmstart); 
    checkParam(pfx.pfx()); 
    printParam(out, pfx.pfx()); 
  } 

  /*------------------------------------------------------------*/  
  #define kw_do_i "Gate_i"
  #define kw_do_f "Gate_f"  
  #define kw_do_o "Gate_o"  
  #define kw_do_no_i "NoGate_i"
  #define kw_do_no_f "NoGate_f"  
  #define kw_do_no_o "NoGate_o"    
  #define kw_bprop_max "bprop_max="
  #define kw_do_align_to_end "AlignToEnd"
  #define kw_f_const "f_const="
  #define kw_do_lstm_stat "LstmStat"
  #define kw_patch "chop_size="  
  #define kw_chopover "chop_overlap=" 
  #define kw_patch_override "chop_size_override="  
  #define kw_chopover_override "chop_overlap_override="   
  #define kw_do_test_with_patch "TestWithChop"    
  #define kw_do_less_traffic "LessTraffic"
  /*------------------------------------------------------------*/  
  void resetParam(AzParam &azp, const char *pfx, bool is_warmstart) {  
    azp.reset_prefix(pfx); 
    if (!is_warmstart) {
      azp.swOff(&do_i, kw_do_no_i); 
      azp.swOff(&do_f, kw_do_no_f); 
      azp.swOff(&do_o, kw_do_no_o);   
      azp.vInt(kw_patch, &patch);       
      azp.vInt(kw_chopover, &chopover);       
    }
    azp.swOn(&do_stat, kw_do_lstm_stat); 
    azp.vInt(kw_patch_override, &patch);  /* override patch */
    azp.vInt(kw_chopover_override, &chopover);  /* override chopover */    
    azp.swOn(&do_test_with_patch, kw_do_test_with_patch);        
    azp.vInt(kw_bprop_max, &bprop_max); 
    azp.swOn(&do_align_to_end, kw_do_align_to_end); 
    if (bprop_max > 0) do_align_to_end = true; 
    azp.swOn(&do_less_traffic, kw_do_less_traffic); 
    azp.reset_prefix();        
  }
  void checkParam(const char *pfx) {
    const char *eyec = "AzpReLayer_LSTM_Param::checkParam"; 
    AzBytArr s(kw_chopover, " must be smaller than "); s << kw_patch << "."; 
    AzX::throw_if(patch > 0 && chopover >= patch, AzInputError, eyec, s.c_str()); 
    if (patch <= 0) chopover = -1; 
    stride = -1; 
    if (patch > 0 && chopover > 0) stride = patch - chopover; 
  }
  void printParam(const AzOut &out, const char *pfx) const {
    AzPrint o(out); 
    o.reset_prefix(pfx);    
    o.printSw(kw_do_lstm_stat, do_stat); 
    o.printSw(kw_do_i, do_i); 
    o.printSw(kw_do_f, do_f); 
    o.printSw(kw_do_o, do_o);     
    o.printV(kw_patch, patch); 
    o.printV(kw_chopover, chopover); 
    o.printSw(kw_do_test_with_patch, do_test_with_patch);    
    o.printV(kw_bprop_max, bprop_max); 
    o.printSw(kw_do_align_to_end, do_align_to_end);    
    o.printSw(kw_do_less_traffic, do_less_traffic); 
    o.printEnd(); 
  }   
  
  void write(AzFile *file) const {
    AzTools::write_header(file, version, reserved_len);  
    file->writeBool(do_i); 
    file->writeBool(do_f); 
    file->writeBool(do_o);     
    file->writeInt(patch); 
    file->writeBool(false); /* for compatibility */
  }
  void read(AzFile *file) {
    AzTools::read_header(file, reserved_len);   
    do_i = file->readBool(); 
    do_f = file->readBool(); 
    do_o = file->readBool();     
    patch = file->readInt(); 
    bool do_c = file->readBool(); /* for compatibility */
  }
}; 

/*---  work area for a recurrent layer  ---*/
class AzpReLayer_LSTM_Work : public virtual AzpReLayer_Wei_Work /* for each position */ {
public:
  AzObjPtrArr<AzpActiv_> act, act_ct; 
  AzPmat m_h, m_c, m_ct, m_ct_act; /* h_{t-1}, c_{t-1}, c_t, act(c_t) */
  AzDataArr<AzPmat> am;  /* i_t, f_t, o_t, u_t */

  AzpReLayer_LSTM_Work() {}
  void reset() {
    AzpReLayer_Wei_Work::reset(); 
    act.free(); act_ct.free(); 
    m_h.destroy(); m_c.destroy(); m_ct.destroy(); m_ct_act.destroy(); 
    am.reset(); 
  }
  virtual ~AzpReLayer_LSTM_Work() { reset(); }
};

class AzpReLayer_LSTM_stat {
public:   
  double ii, ff, oo; 
  double i_sum, f_sum, o_sum, i2_sum, f2_sum, o2_sum; 
  AzpReLayer_LSTM_stat() : ii(0), ff(0), oo(0), i_sum(0), f_sum(0), o_sum(0), i2_sum(0), f2_sum(0), o2_sum(0) {}
  void init() {
    ii = ff = oo = i_sum = f_sum = o_sum = i2_sum = f2_sum = o2_sum = 0;      
  }
  void accum(const AzPmat *m_i, const AzPmat *m_o, const AzPmat *m_f) {
    const AzPmat *m; 
    m = m_i; ii += m->size(); i_sum += m->sum(); i2_sum += m->squareSum(); 
    m = m_o; oo += m->size(); o_sum += m->sum(); o2_sum += m->squareSum(); 
    m = m_f; ff += m->size(); f_sum += m->sum(); f2_sum += m->squareSum();     
  }
  void show_stat(AzBytArr &s) const {
    if (ii > 0) s << "iavg=" << i_sum/ii << ";isdev=" << sqrt(i2_sum/ii - i_sum/ii*i_sum/ii) << ";"; 
    if (oo > 0) s << "oavg=" << o_sum/oo << ";osdev=" << sqrt(o2_sum/oo - o_sum/oo*o_sum/oo) << ";";     
    if (ff > 0) s << "favg=" << f_sum/ff << ";fsdev=" << sqrt(f2_sum/ff - f_sum/ff*f_sum/ff) << ";";     
  } 
}; 

/*------------------------------------------------------------*/  
class AzpReLayer_LSTM : public virtual AzpReLayer_Wei_ {
protected:
  int file_ver, _u_, _f_, _i_, _o_; 
  AzpReLayer_LSTM_Param p; 
  AzPmat m_sv_h; 
  
  bool do_backward; 
  AzDataArr<AzBytArr> wei_pfx; 
  AzDataArr<AzBytArr> act_pfx; 
  AzpWeight_ *wei_h; 
  AzpActiv_ *act_g, *act_c; 

  AzpReLayer_Wei_InOut io;   
  AzDataArr<AzpReLayer_LSTM_Work> aw; 

  AzBaseArr<bool> ado_ifuo; 
  int ifuo_num; 
  void init_do_ifuo(); 

  AzpReLayer_LSTM_stat stat; 
  AzBytArr s_stat; 
  void stat_accum(const AzpReLayer_LSTM_Work *cw) {
    if (!p.do_stat) return; 
    if (cw == NULL) return; 
    stat.accum(cw->am[_i_], cw->am[_o_], cw->am[_f_]);     
  }
  virtual void reset() {
    AzpReLayer_Wei_::reset(); 
    aw.reset(); 
    wei_pfx.reset(); act_pfx.reset(); 
    wei_h = NULL; 
    act_g = act_c = NULL; 
  }  
  
/*  static const int version = 0; */
  static const int version = 1; /* for ifuo -> ufio */
  static const int reserved_len = 64;   
  AzpReLayer_LSTM() : file_ver(-1), do_backward(false), wei_h(NULL), act_g(NULL), act_c(NULL), ifuo_num(-1),
                       _u_(0), _f_(1), _i_(2), _o_(3) {} 
public:
  virtual ~AzpReLayer_LSTM() { reset(); }
  virtual void init_wei() {
    wei.free_alloc(3);
    for (int ix = 0; ix < wei.size(); ++ix) wei.set(ix, cs.weight->clone()); 
    wei_x = wei(0); wei_h = wei(1); wei_x2 = wei(2);   
    wei_pfx.reset(3); 
    wei_pfx(0)->reset("x_"); wei_pfx(1)->reset("h_"); wei_pfx(2)->reset("x2_"); 
  }
  virtual void init_act() {
    act.free_alloc(3); 
    for (int ix = 0; ix < act.size(); ++ix) act.set(ix, cs.activ->clone()); 
    act_x = act(0); act_c = act(1); act_g = act(2); 
    act_pfx.reset(3); 
    act_pfx(0)->reset("x_"); act_pfx(1)->reset("c_"); act_pfx(2)->reset("gate_");     
  }
  virtual void check_if_ready(const char *msg) const {
    AzpReLayer_Wei_::check_if_ready(msg); 
    AzX::throw_if(wei_h==NULL, msg, "null wei_h"); 
    AzX::throw_if(act_g==NULL, msg, "null act_g"); 
    AzX::throw_if(act_c==NULL, msg, "null act_c");     
  }                
  virtual void _write(AzFile *file) const {
    AzpReLayer_Wei_::_write(file); 
    AzTools::write_header(file, version, reserved_len); 
    p.write(file);    
  }
  virtual void _read(AzFile *file) {
    AzpReLayer_Wei_::_read(file); 
    file_ver = AzTools::read_header(file, reserved_len);
    if (file_ver == 0) { _i_=0; _f_=1; _u_=2; _o_=3; } /* for file compatibility */
    p.read(file); 
  }  

  virtual void show_stat(AzBytArr &s) const { 
    s << s_stat;
    AzpReLayer_Wei_::show_stat(s); 
  }
  virtual void end_of_epoch() {
    AzpReLayer_Wei_::end_of_epoch(); 
    if (p.do_stat) { s_stat.reset(); stat.show_stat(s_stat); stat.init(); }
  }

protected:  
  bool is_re() const { return true; }
  virtual int wei_setup(AzParam &azp, const AzpReLayer_Param &pp, const AzPfx &pfx, bool is_warmstart, bool for_testonly);   
  template <class M> int init_work(const M &mv_below, bool is_test); 
  virtual void wei_upward_dense(bool is_test, const AzPmatVar &mi, AzPmatVar &mo, const AzPmatVar *mv2) { _upward(is_test,mi,mo,mv2); }
  virtual void wei_upward_sparse(bool is_test, const AzPmatSpaVar &mi, AzPmatVar &mo, const AzPmatVar *mv2) { _upward(is_test,mi,mo,mv2); }  
  template <class M> void _upward(bool is_test, const M &mv_below, AzPmatVar &mv_out, const AzPmatVar *mv2);
  virtual void wei_downward(const AzPmatVar &mv, bool dont_update);   
  virtual void wei_downward(bool dont_update) { /* this should not be called, though */
    AzPmatVar mv_ld(&mv_ld_x); wei_downward(mv_ld_x, dont_update); 
  }
  virtual int how_far_bprop() const; 
}; 

class AzpReLayer_LstmF : public virtual AzpReLayer_LSTM {
public:
  AzpReLayer_LstmF() {
    do_backward = false; 
    s_nm.reset(AzpReLayer_Type_LstmF); 
  } 
};
class AzpReLayer_LstmB : public virtual AzpReLayer_LSTM {
public:
  AzpReLayer_LstmB() {
    do_backward = true; 
    s_nm.reset(AzpReLayer_Type_LstmB); 
  } 
};

/*------------------------------------------------------------*/ 
/*                  Layer without weights                     */
/*------------------------------------------------------------*/ 
class AzpReLayer_NoWei_ : public virtual AzpReLayer_ {
protected:  
  AzpLayerCompoPtrs cs; 
public:
  AzpReLayer_NoWei_() {}
  virtual ~AzpReLayer_NoWei_() {}  
  virtual void reset(const AzpCompoSet_ *cset) {
    cs.reset(cset);     
  }
  virtual void _write(AzFile *file) const { 
    file->writeInt(layer_no); 
    cs.write(file); 
  }
  virtual void _read(AzFile *file) { 
    layer_no = file->readInt(); 
    cs.read(file); 
  }                
  virtual void upward(bool is_test, const AzDataArr<AzpDataVar_X> &data, AzPmatVar &mv_out, const AzPmatVar *mv2=NULL) {
    const char *eyec = "AzpReLayer_NoWei_::upward";    
    AzX::no_support(true, eyec, "upward with input data"); 
  }
  virtual void upward2(const AzPmatVar &mv_inp, AzPmatVar &mv_out, bool do_update=false) { upward(true, mv_inp, mv_out); }
  /*====================================*/  
  virtual void upward(bool is_test, const AzPmatVar &mv_below, AzPmatVar &mv_out, const AzPmatVar *mv2=NULL) = 0; 
  virtual void get_ld(int id, AzPmatVar &mv_lossd_a, bool do_x2=false) const = 0;   
  /*====================================*/  
  
  virtual void downward(const AzPmatVar &mv_loss_deriv, bool dont_update=false, bool dont_release_sv=false) {} /* do it in get_ld */
  virtual void flushDelta() {}
  virtual void end_of_epoch() {}
  virtual void show_stat(AzBytArr &s) const {}
  virtual void multiply_to_stepsize(double coeff, const AzOut *out) {}
  virtual double regloss(double *out_iniloss=NULL) const { return 0; }
  virtual void release_ld() { cs.activ->release_ld(); }
  
protected:   
  virtual int setup(AzParam &azp, const AzpReLayer_Param &pp, const AzPfx &pfx, bool is_warmstart, bool for_testonly) {
    const char *eyec = "AzpReLayer_NoWei_::setup"; 
    cs.check_if_ready(eyec); 
    AzX::throw_if_null(upper, eyec, "A NoWei layer cannot be the top layer."); 
    return nowei_setup(azp, pp, pfx, is_warmstart, for_testonly); 
  } 
  /*====================================*/
  virtual int nowei_setup(AzParam &azp, const AzpReLayer_Param &pp, const AzPfx &pfx, bool is_warmstart, bool for_testonly) = 0; 
  /*====================================*/   
};

/*------------------------------------------------------------*/ 
class AzpReLayer_Pooling : public virtual AzpReLayer_NoWei_ {
public:
  AzpReLayer_Pooling() { s_nm.reset(AzpReLayer_Type_Pooling); }
  virtual ~AzpReLayer_Pooling() {}  
  virtual int nowei_setup(AzParam &azp, const AzpReLayer_Param &pp, const AzPfx &pfx, bool is_warmstart, bool for_testonly) {      
    no_support_sparse(pp);                      
    cs.pool_var->resetParam(out, azp, pfx, is_warmstart); cs.pool_var->reset(out); 
    cs.resnorm->resetParam(out, azp, pfx, is_warmstart);  cs.resnorm->reset(out, NULL, pp.cc); 
    return pp.cc; 
  }                                 
  virtual void upward(bool is_test, const AzPmatVar &mv_below, AzPmatVar &mv_out, const AzPmatVar *mv2=NULL) {
    no_support2(mv2, "AzpReLayer_Pooling::upward"); 
    cs.pool_var->upward(is_test, &mv_below, &mv_out);
    cs.resnorm->upward(is_test, mv_out.data_u()); 
  }
  virtual void get_ld(int id, AzPmatVar &mv_lossd_a, bool do_x2=false) const {
    AzPmatVar mv; upper->get_ld(layer_no, mv); 
    cs.resnorm->downward(mv.data_u());
    cs.pool_var->downward(&mv, &mv_lossd_a);
  }
};

/*------------------------------------------------------------*/ 
class AzpReLayer_Patch : public virtual AzpReLayer_NoWei_ {
protected:  
public:
  AzpReLayer_Patch() { s_nm.reset(AzpReLayer_Type_Patch); }
  virtual ~AzpReLayer_Patch() {}  
  virtual int nowei_setup(AzParam &azp, const AzpReLayer_Param &pp, const AzPfx &pfx, bool is_warmstart, bool for_testonly) {
    no_support_sparse(pp);  
    cs.patch_var->resetParam(out, azp, pfx, is_warmstart); cs.patch_var->reset(out, pp.cc, pp.is_spa); 
    AzPrint::writeln(out, "");     
    return cs.patch_var->patch_length(); 
  }                                 
  virtual void upward(bool is_test, const AzPmatVar &mv_below, AzPmatVar &mv_out, const AzPmatVar *mv2) {
    no_support2(mv2, "AzpReLayer_Patch::upward");   
    cs.patch_var->upward(is_test, &mv_below, &mv_out); 
  }
  virtual void get_ld(int id, AzPmatVar &mv_lossd_a, bool do_x2=false) const {
    AzPmatVar mv; upper->get_ld(layer_no, mv); 
    cs.patch_var->downward(&mv, &mv_lossd_a); 
  }
};

/*------------------------------------------------------------*/ 
class AzpReLayer_Dropout : public virtual AzpReLayer_NoWei_ {
public:
  AzpReLayer_Dropout() { s_nm.reset(AzpReLayer_Type_Dropout); }
  virtual ~AzpReLayer_Dropout() {}  
  virtual int nowei_setup(AzParam &azp, const AzpReLayer_Param &pp, const AzPfx &pfx, bool is_warmstart, bool for_testonly) {
    no_support_sparse(pp); 
    cs.dropout->resetParam(out, azp, pfx, for_testonly); cs.dropout->reset(out); 
    return pp.cc; 
  }                                 
  virtual void upward(bool is_test, const AzPmatVar &mv_below, AzPmatVar &mv_out, const AzPmatVar *mv2=NULL) {
    no_support2(mv2, "AzpReLayer_Dropout::upward"); 
    mv_out.set(&mv_below); 
    cs.dropout->upward(is_test, mv_out.data_u()); 
  }
  virtual void get_ld(int id, AzPmatVar &mv_lossd_a, bool do_x2=false) const {
    upper->get_ld(layer_no, mv_lossd_a); 
    cs.dropout->downward(mv_lossd_a.data_u());
  }
};

/*------------------------------------------------------------*/ 
class AzpReLayer_Act : public virtual AzpReLayer_NoWei_ {
public:
  AzpReLayer_Act() { s_nm.reset(AzpReLayer_Type_Act); }
  virtual ~AzpReLayer_Act() {}  
  virtual int nowei_setup(AzParam &azp, const AzpReLayer_Param &pp, const AzPfx &pfx, bool is_warmstart, bool for_testonly) {
    no_support_sparse(pp); 
    cs.activ->resetParam(out, azp, pfx, is_warmstart); cs.activ->reset(out); 
    return pp.cc; 
  }                                 
  virtual void upward(bool is_test, const AzPmatVar &mv_below, AzPmatVar &mv_out, const AzPmatVar *mv2=NULL) {
    no_support2(mv2, "AzpReLayer_Act::upward"); 
    mv_out.set(&mv_below); 
    cs.activ->upward(is_test, mv_out.data_u());
  }
  virtual void upward2(const AzPmatVar &mv_inp, AzPmatVar &mv_out, bool do_update=false) {
    mv_out.set(&mv_inp); 
    cs.activ->upward2(mv_out.data_u());
  }  
  virtual void get_ld(int id, AzPmatVar &mv_lossd_a, bool do_x2=false) const {
    upper->get_ld(layer_no, mv_lossd_a); 
    cs.activ->downward(mv_lossd_a.data_u());
  }
};

/*------------------------------------------------------------*/ 
class AzpReLayer_PassLast : public virtual AzpReLayer_NoWei_ {
protected:  
  AzIntArr ia_ind, ia_last; 
public:
  AzpReLayer_PassLast() { s_nm.reset(AzpReLayer_Type_PassLast); }
  virtual ~AzpReLayer_PassLast() {}  
  virtual int nowei_setup(AzParam &azp, const AzpReLayer_Param &pp, const AzPfx &pfx, bool is_warmstart, bool for_testonly) {
    no_support_sparse(pp);                            
    return pp.cc; 
  }                                
  virtual void upward(bool is_test, const AzPmatVar &mv_below, AzPmatVar &mv_out, const AzPmatVar *mv2) {   
    no_support2(mv2, "AzpReLayer_PassLast::upward");     
    ia_ind.reset(mv_below.h_index()); ia_last.reset(); 
    AzIntArr ia;     
    for (int dx = 0; dx < mv_below.dataNum(); ++dx) { 
      ia.put(dx); ia.put(dx+1); 
      AzX::no_support(mv_below.get_end(dx)-mv_below.get_begin(dx) <= 0, 
                      "AzpReLayer_PassLast::upward", "a data item of zero length (e.g., an empty document)"); 
      ia_last.put(mv_below.get_end(dx)-1); /* last column of each data item */
    }
    mv_out.reform(mv_below.rowNum(), &ia); 
    mv_out.data_u()->set(mv_below.data(), ia_last);
    mv_out.check_colNum("AzpReLayer_PassLast::upward,mv_out"); 
  }
  virtual void get_ld(int id, AzPmatVar &mv_lossd_a, bool do_x2=false) const {
    const char *eyec = "AzpReLayer_PassLast::get_ld"; 
    AzPmatVar mv; upper->get_ld(layer_no, mv);     
    AzX::throw_if(ia_last.size() != mv.colNum() || ia_last.size() != mv.dataNum(), eyec, "#col/#data conflict"); 
    mv_lossd_a.reform(mv.rowNum(), &ia_ind); 
    mv_lossd_a.data_u()->copy_dcol(mv.data(), ia_last); 
    mv_lossd_a.check_colNum(eyec); 
  }
};

/*------------------------------------------------------------*/ 
/* do nothing */
class AzpReLayer_Noop : public virtual AzpReLayer_ {
protected:  
  AzPmatVar mv_ld; 
  int dsno;    
  void resetParam(const AzOut &out, AzParam &azp, const char *pfx) { 
    azp.reset_prefix(pfx); azp.vInt(kw_dsno, &dsno); azp.reset_prefix(); 
    AzPrint o(out, pfx); o.printV(kw_dsno, dsno); o.ppEnd(); 
  }
  virtual int setup(AzParam &azp, const AzpReLayer_Param &pp, const AzPfx &pfx, 
                    bool is_warmstart=false, bool for_testonly=false) {
    for (int px=0; px<pfx.size(); ++px) resetParam(out, azp, pfx[px]); 
    int dim = pp.cc; 
    AzX::throw_if(dsno >= 0 && pp.ia_dscc[dsno] != dim, s_nm.c_str(), "Dimensionality mismatch in setup"); 
    AzPrint::writeln(out, "   output dim = ", dim); 
    return dim; 
  }                    

public:
  AzpReLayer_Noop() : dsno(-1) { s_nm.reset(AzpReLayer_Type_Noop); }
  virtual ~AzpReLayer_Noop() {}  
  virtual void reset(const AzpCompoSet_ *cset) {}
  virtual void _write(AzFile *file) const { 
    file->writeInt(layer_no); /* for compatibility */
    file->writeInt(dsno);  
  }
  virtual void _read(AzFile *file) { 
    layer_no = file->readInt(); /* for compatibility */
    dsno = file->readInt(); 
  }
  virtual void upward(bool is_test, const AzDataArr<AzpDataVar_X> &arr, AzPmatVar &mvo, const AzPmatVar *mv2=NULL) {
    AzX::throw_if(dsno >= arr.size(), "AzpReLayer_Noop::upward(data)", "data# is out of range"); 
    arr[MAX(0,dsno)]->get(mvo); 
  }  
  virtual void upward(bool is_test, const AzPmatVar &mvi, AzPmatVar &mvo, const AzPmatVar *mv2=NULL) {
    mvo.set(&mvi);  
  }
  virtual void upward2(const AzPmatVar &mvi, AzPmatVar &mvo, bool do_update=false) { upward(true, mvi, mvo); }
  virtual void get_ld(int id, AzPmatVar &mv_lossd_a, bool do_x2=false) const {
    mv_lossd_a.set(&mv_ld); 
  }
  virtual void downward(const AzPmatVar &mv_loss_deriv, bool dont_update=false, bool dont_release_sv=false) {
    if (upper != NULL) upper->get_ld(layer_no, mv_ld); 
    else               mv_ld.set(&mv_loss_deriv); 
  }
  virtual void flushDelta() {}
  virtual void end_of_epoch() {}
  virtual void show_stat(AzBytArr &s) const {}
  virtual void multiply_to_stepsize(double coeff, const AzOut *out) {}
  virtual double regloss(double *out_iniloss=NULL) const { return 0; }
};

/*------------------------------------------------------------*/ 
class AzpReLayer_ComboH_Param {
protected: 
  static const int version = 0; 
/*  static const int reserved_len = 64; */
  static const int reserved_len = 63; /* 12/17/2015: for do_split_side */
public: 
  bool do_sum, do_avg, do_multi, do_split_side; 

  AzpReLayer_ComboH_Param() : do_sum(false), do_avg(false), do_multi(false), do_split_side(false) {}
  bool do_concat() const { return !do_sum && !do_avg && !do_multi; }
   
  virtual void resetParam(const AzOut &out, AzParam &azp, const AzPfx &pfx, bool is_warmstart=false) {
    for (int px=0; px<pfx.size(); ++px) resetParam(azp, pfx[px], is_warmstart); 
    checkParam(pfx.pfx()); 
    printParam(out, pfx.pfx()); 
  }                         
  /*------------------------------------------------------------*/  
  #define kw_do_avg "AvgCombo"
  #define kw_do_sum "SumCombo"
  #define kw_do_multi "MultiCombo"
  #define kw_do_split_side "SplitSide"
  /*------------------------------------------------------------*/  
  virtual void resetParam(AzParam &azp, const char *pfx, bool is_warmstart=false) {     
    azp.reset_prefix(pfx); 
    if (!is_warmstart) {
      azp.swOn(&do_sum, kw_do_sum); 
      if (!do_sum) azp.swOn(&do_avg, kw_do_avg); 
      if (!do_sum&&!do_avg) azp.swOn(&do_multi, kw_do_multi); 
      azp.swOn(&do_split_side, kw_do_split_side); 
    }
    azp.reset_prefix();        
  }
  virtual void checkParam(const char *pfx) const {}
  virtual void printParam(const AzOut &out, const char *pfx) const {
    if (out.isNull()) return; 
    AzPrint o(out); 
    o.reset_prefix(pfx);    
    o.printSw(kw_do_sum, do_sum); 
    o.printSw(kw_do_avg, do_avg); 
    o.printSw(kw_do_multi, do_multi);     
    o.printSw(kw_do_split_side, do_split_side); 
    o.printEnd(); 
  }   
  
  virtual void write(AzFile *file) const {
    AzTools::write_header(file, version, reserved_len); 
    file->writeBool(do_split_side); 
    file->writeBool(do_sum); 
    file->writeBool(do_avg); 
    file->writeBool(do_multi);     
  }
  virtual void read(AzFile *file) {
    AzTools::read_header(file, reserved_len);
    do_split_side = file->readBool(); 
    do_sum = file->readBool(); 
    do_avg = file->readBool(); 
    do_multi = file->readBool();     
  } 
};

/*------------------------------------------------------------*/  
class AzpReLayer_ComboH_ : public virtual AzpReLayer_ { /* H for horizontal */
protected:   
  AzpReLayer_ComboH_Param p; 
  AzBaseArr<AzpReLayer_ *> lp; /* just pointing them.  not owning */
                               /* derived classes must guaranteed that no element is null */                          
  AzPmatVar mv_lossd; 
  
  AzIIarr iia_rows;
  AzDataArr<AzPmat> am_sv; /* for multi (only combo of two is allowed) */
  
public:   
  AzpReLayer_ComboH_() { s_nm.reset("Combo"); }
  virtual ~AzpReLayer_ComboH_() {}

  virtual void reset(const AzpCompoSet_ *cset)  { for (int i=0; i<lp.size(); ++i) lp[i]->reset(cset); }
  virtual void _write(AzFile *file) const { file->writeInt(layer_no); p.write(file); combo_write(file); }
  virtual void _read(AzFile *file)  { layer_no = file->readInt(); p.read(file); combo_read(file); }
  virtual void upward(bool is_test, const AzDataArr<AzpDataVar_X> &data, AzPmatVar &mv_out, const AzPmatVar *mv2=NULL) { 
    _upward(is_test, data, mv_out, mv2); 
  }
  virtual void upward(bool is_test, const AzPmatVar &mv_below, AzPmatVar &mv_out, const AzPmatVar *mv2=NULL) { 
    _upward(is_test, mv_below, mv_out, mv2); 
  }  
  virtual void downward(const AzPmatVar &mv_loss_deriv, bool dont_update=false, bool dont_release_sv=false); 
  virtual void flushDelta() { for (int i=0; i<lp.size(); ++i) lp[i]->flushDelta(); }
  virtual void end_of_epoch() { for (int i=0; i<lp.size(); ++i) lp[i]->end_of_epoch(); }
  virtual void show_stat(AzBytArr &s) const { s << "conn:"; for (int i=0; i<lp.size(); ++i) lp[i]->show_stat(s); }
  virtual void multiply_to_stepsize(double coeff, const AzOut *out) { for (int i=0; i<lp.size(); ++i) lp[i]->multiply_to_stepsize(coeff, out); }
  virtual double regloss(double *out_iniloss=NULL) const { double val=0; for (int i=0; i<lp.size(); ++i) val += lp[i]->regloss(out_iniloss); return val; }
  virtual void get_ld(int id, AzPmatVar &mv_lossd_a, bool do_x2=false) const; 
  
  virtual void check_word_mapping(const AzpData_tmpl_ *data) { for (int i=0; i<lp.size(); ++i) lp[i]->check_word_mapping(data); }
  virtual bool doing_adv() const { 
    for (int i=0; i<lp.size(); ++i) if (lp[i]->doing_adv()) return true; 
    return false; 
  }
  
protected:   
  virtual int setup(AzParam &azp, const AzpReLayer_Param &pp, const AzPfx &pfx, bool is_warmstart, bool for_testonly);
  template <class X> void _upward(bool is_test, const X &data, AzPmatVar &mv_out, const AzPmatVar *mv2=NULL); 
  virtual void gen_prefix_combo(int ix, const AzPfx &inp_pfx, AzPfx &pfx) const; 
  /*=====================================*/
  virtual void combo_write(AzFile *file) const = 0; 
  virtual void combo_read(AzFile *file) = 0; 
  /*=====================================*/  
}; 

/*------------------------------------------------------------*/  
/*---  bi-directional LSTM  ---*/
class AzpReLayer_Lstm2 : public virtual AzpReLayer_ComboH_ {
protected: 
  AzpReLayer_LstmF f_lay;
  AzpReLayer_LstmB b_lay; 

public:   
  AzpReLayer_Lstm2() {
    lp.alloc(2, (AzpReLayer_ *)NULL); 
    lp(0, &f_lay); 
    lp(1, &b_lay); 
    s_nm.reset(AzpReLayer_Type_Lstm2); 
  }
  virtual ~AzpReLayer_Lstm2() {}
  virtual void combo_read(AzFile *file)  { f_lay.read(file); b_lay.read(file); }
  virtual void combo_write(AzFile *file) const { f_lay.write(file); b_lay.write(file); }  
}; 

/*------------------------------------------------------------*/ 
class AzpReLayer_DenseWei_ : public virtual AzpReLayer_ {
protected:   
  AzpLayerCompoPtrs cs; 
  AzObjPtrArr<AzpWeight_> wei;
  AzPmatVar mv_sv, mv_ld; 
  int nn, dsno, nodes; 
  virtual void resetParam(const AzOut &out, AzParam &azp, const AzPfx &pfx, bool is_warmstart=false) {
    for (int px=0; px<pfx.size(); ++px) resetParam(azp, pfx[px], is_warmstart); 
    printParam(out, pfx.pfx()); 
    AzXi::throw_if_nonpositive(nodes, "AzpReLayer_DenseWei_::resetParam", kw_nodes, pfx.pfx());  
  }                         
  virtual void resetParam(AzParam &azp, const char *pfx, bool is_warmstart=false, bool is_top=false) {     
    azp.reset_prefix(pfx); 
    if (!is_warmstart && !is_top) azp.vInt(kw_nodes, &nodes); 
    azp.vInt(kw_dsno, &dsno); 
    azp.reset_prefix();
  }
  virtual void printParam(const AzOut &out, const char *pfx) const {
    AzPrint o(out); o.reset_prefix(pfx); 
    o.printV(kw_nodes, nodes); 
    if (dsno != 0) o.printV(kw_dsno, dsno); 
  }   
  static const int version = 0; 
/*  static const int reserved_len = 64; */
  static const int reserved_len = 60; /* 7/18/2017: for dsno */
public:
  AzpReLayer_DenseWei_(int _nn) : nodes(-1), nn(0), dsno(0) { nn = _nn; }
  virtual ~AzpReLayer_DenseWei_() {}

  virtual void reset() {
    wei.free();
    upper = NULL; 
    release_all(); 
  }
  virtual void reset(const AzpCompoSet_ *cset) {
    reset(); cs.reset(cset); 
    init_wei();
    check_if_ready("AzpReLayer_DenseWei_::reset"); 
  }
  virtual void check_if_ready(const char *msg) const {
    cs.check_if_ready(msg);  
    wei.check_if_ready(msg, "wei"); 
  } 
  virtual void _write(AzFile *file) const {
    check_if_ready("AzpReLayer_DenseWei_::_write"); 
    AzTools::write_header(file, version, reserved_len); 
    file->writeInt(dsno); 
    file->writeInt(nodes); 
    file->writeInt(nn); 
    for (int ix = 0; ix < nn; ++ix) wei[ix]->write(file); 
  }
  virtual void _read(AzFile *file) {
    cs.check_if_ready("AzpReLayer_DenseWei_::_read"); 
    AzTools::read_header(file, reserved_len);
    dsno = file->readInt(); 
    nodes = file->readInt(); 
    nn = file->readInt(); 
    for (int ix = 0; ix < nn; ++ix) wei(ix)->read(file); 
  }
  /*===================================*/
  virtual void upward(bool is_test, const AzPmatVar &mv_below, AzPmatVar &mv_out, const AzPmatVar *mv2=NULL) = 0; 
  virtual void downward(const AzPmatVar &mv_loss_deriv, bool dont_update=false, bool dont_release_sv=false) = 0; 
  virtual void get_ld(int id, AzPmatVar &mv_lossd_a, bool do_x2=false) const = 0; 
  /*===================================*/
  virtual void upward(bool is_test, const AzDataArr<AzpDataVar_X> &dataarr, AzPmatVar &mv_out, const AzPmatVar *mv2=NULL) {
    AzX::throw_if(dsno >= dataarr.size(), "AzpReLayer_Dense_Wei_::upward", "dsno is out of range"); 
    const AzpDataVar_X *data = dataarr[MAX(0,dsno)]; 
    AzX::no_support(!data->is_den(), "AzpDenseWei_::upward", "sparse input");     
    upward(is_test, *data->den(), mv_out, mv2); 
  }
  virtual void flushDelta() { for (int i=0;i<wei.size();++i) wei(i)->flushDelta(); }
  virtual void end_of_epoch() { for (int i=0;i<wei.size();++i)wei(i)->end_of_epoch(); }  
  virtual void show_stat(AzBytArr &s) const { for (int i=0;i<wei.size();++i) wei[i]->show_stat(s); }
  virtual void multiply_to_stepsize(double coeff, const AzOut *out) { 
    for (int i=0;i<wei.size();++i) wei(i)->multiply_to_stepsize(coeff, out); 
  }  
  virtual double regloss(double *out_iniloss=NULL) const { double val=0; for (int i=0;i<wei.size();++i) val+= wei[i]->regloss(out_iniloss); return val;}
  virtual void release_ld() { mv_ld.destroy(); }  
  virtual void release_sv() { mv_sv.destroy(); }
  
protected:  
  virtual void init_wei() {
    cs.check_if_ready("AzpReLayer_DnWei_::init_wei"); 
    wei.free_alloc(nn); 
    for (int ix = 0; ix < nn; ++ix) wei.set(ix, cs.weight->clone()); 
  } 
  virtual void release_all() { mv_sv.destroy(); mv_ld.destroy(); }  
  virtual int setup(AzParam &azp, const AzpReLayer_Param &pp, const AzPfx &pfx, bool is_warmstart, bool for_testonly) {
    const char *eyec = "AzpReLayer_DenseWei_::setup";                                   
    AzX::no_support(pp.cc2 > 0, eyec, "side"); 
    if (is_top()) nodes = pp.class_num; 
    else          resetParam(out, azp, pfx, is_warmstart); 
    if (!for_testonly) for (int ix=0;ix<nn;++ix) wei(ix)->resetParam(out, azp, pfx, is_warmstart); 
    setup_wei(); 
    if (!is_warmstart) for (int ix=0;ix<nn;++ix) wei(ix)->reset(-1, nodes, pp.cc, pp.is_spa, false); 
    for (int ix=0;ix<nn;++ix) { AzBytArr s("wei"); s << ix; show_weight_dim(wei[ix], s.c_str()); }
    if (!is_warmstart) for (int ix=0;ix<nn;++ix) wei(ix)->initWeights(); 
    return nodes;     
  }     
  virtual void setup_wei() {} /* override this */   
};       

/*------------------------------------------------------------*/   
class AzpReLayer_DenWei : public virtual AzpReLayer_DenseWei_ {
public: 
  AzpReLayer_DenWei() : AzpReLayer_DenseWei_(1) {s_nm.reset(AzpReLayer_Type_DenWei); }
  virtual ~AzpReLayer_DenWei() {}
  virtual void upward(bool is_test, const AzPmatVar &mvi, AzPmatVar &mvo, const AzPmatVar *mv2=NULL) {
    if (!is_test) mv_sv.set(&mvi); 
    mvo.reform(1, mvi.d_index());   
    wei(0)->upward(is_test, mvi.data(), mvo.data_u());
  }
  virtual void downward(const AzPmatVar &_mv, bool dont_update=false, bool dont_release_sv=false) {
    if (is_top()) mv_ld.set(&_mv); 
    else          upper->get_ld(layer_no, mv_ld); 
    if (!dont_update) updateDelta(); 
    if (!dont_release_sv) release_sv(); 
  }
  virtual void get_ld(int id, AzPmatVar &mvo, bool do_x2=false) const {   
    mvo.reform(1, mv_ld.d_index()); 
    wei[0]->downward(mv_ld.data(), mvo.data_u()); 
  } 
  virtual void upward2(const AzPmatVar &mvi, AzPmatVar &mvo, bool do_update=false) {  
    /* don't save */
    /* mv_ld serves as saved input.  mvi serves as derivatives.  Updating W^T */
    upward(true, mvi, mvo); 
    if (do_update) {
      AzX::throw_if(mv_ld.colNum() != mvi.colNum(), "AzpReLayer_DenWei::upward2", "No ld"); 
      wei(0)->updateDelta(mvi.dataNum(), mvi.data(), mv_ld.data());       
    }
  } 
protected:   
  virtual void updateDelta() {
    AzX::throw_if(mv_sv.colNum() <= 0, "AzpReLayer_DenWei::updateDelta", "No saved input"); 
    AzX::throw_if(mv_ld.colNum() != mv_sv.colNum(), "AzpReLayer_DenWei::updateDelta", "No ld");     
    wei(0)->updateDelta(mv_sv.dataNum(), mv_sv.data(), mv_ld.data());      
  }  
}; 

/*------------------------------------------------------------*/  
class AzpReLayers {
protected: 
  AzDataArr<AzBytArr> as_typ; 
  AzObjPtrArr<AzpReLayer_> a;   
  static const int version = 0; 
  static const int reserved_len = 64;   
public: 
  virtual ~AzpReLayers() {
    reset(); 
  }
  virtual void reset() {
    a.free(); 
    as_typ.reset(); 
  }
  virtual void reset(int num) {
    reset(); 
    a.free_alloc(num); 
    as_typ.reset(num); 
  }  
  virtual void reset(int index, const char *typ, const AzpCompoSet_ *cset) {  
    AzBytArr s_typ(typ); 
    reset(index, &s_typ, cset); 
  }
  virtual void reset(int index, const AzBytArr *s_typ, const AzpCompoSet_ *cset) {
    const char *eyec = "AzpReLayer::reset(index,ptr)"; 
    check_index(index, eyec); 
    AzX::throw_if_null(cset, eyec, "null component set"); 
    as_typ(index)->reset(s_typ); 
    _init_layer(index, cset); 
  }
     
  virtual int size() const { return a.size(); }
  
  const AzpReLayer_ *operator[](int index) const { 
    const char *eyec = "AzpReLayers []"; 
    check_index(index, eyec); 
    const AzpReLayer_ *ptr = a[index]; 
    AzX::throw_if((ptr == NULL), eyec, "Illegal access to an uninitialized layer"); 
    return ptr; 
  }
  AzpReLayer_ *operator()(int index) {
    const char *eyec = "AzpReLayers ()";     
    check_index(index, eyec); 
    AzpReLayer_ *ptr = a(index); 
    AzX::throw_if((ptr == NULL), eyec, "Illegal access to an uninitialized layer"); 
    return ptr; 
  }  
  virtual void write(AzFile *file) const {
    const char *eyec = "AzpReLayers::write"; 
    AzTools::write_header(file, version, reserved_len);   
    as_typ.write(file); 
    for (int lx = 0; lx < as_typ.size(); ++lx) (*this)[lx]->write(file); 
  }
  virtual void read(const AzpCompoSet_ *cset, AzFile *file) {
    AzX::throw_if((cset == NULL), "AzpReLayers::read", "No component set");   
    reset(); 
    AzTools::read_header(file, reserved_len);
    as_typ.read(file); 
    int num = as_typ.size(); 
    a.free_alloc(num); 
    for (int lx = 0; lx < num; ++lx) {
      _init_layer(lx, cset); 
      (*this)(lx)->read(file); 
    }
  }  
  
protected: 
  virtual void check_index(int index, const char *eyec) const {
    AzX::throw_if((index < 0 || index >= a.size()), eyec, "index is out of range (1)"); 
    AzX::throw_if((index < 0 || index >= as_typ.size()), eyec, "index is out of range (2)");     
  }  
  virtual void _init_layer(int index, const AzpCompoSet_ *cset) {
    const char *eyec = "_init_layer"; 
    check_index(index, eyec); 
    AzBytArr s_typ(as_typ[index]); 
    if (s_typ.length() <= 0) s_typ.reset(AzpReLayer_Type_Fc); 
    AzpReLayer_ *ptr = NULL;
    if      (s_typ.equals(AzpReLayer_Type_Fc))      ptr = new AzpReLayer_Fc(); 
    else if (s_typ.equals(AzpReLayer_Type_FcS))     ptr = new AzpReLayer_FcS(); 
    else if (s_typ.equals(AzpReLayer_Type_DenWei))  ptr = new AzpReLayer_DenWei();     
    else if (s_typ.equals(AzpReLayer_Type_LstmF))   ptr = new AzpReLayer_LstmF(); 
    else if (s_typ.equals(AzpReLayer_Type_LstmB))   ptr = new AzpReLayer_LstmB();     
    else if (s_typ.equals(AzpReLayer_Type_Lstm2))   ptr = new AzpReLayer_Lstm2();        
    else if (s_typ.equals(AzpReLayer_Type_Pooling)) ptr = new AzpReLayer_Pooling(); 
    else if (s_typ.equals(AzpReLayer_Type_PassLast))ptr = new AzpReLayer_PassLast();     
    else if (s_typ.equals(AzpReLayer_Type_Patch))   ptr = new AzpReLayer_Patch();      
    else if (s_typ.equals(AzpReLayer_Type_Dropout)) ptr = new AzpReLayer_Dropout();     
    else if (s_typ.equals(AzpReLayer_Type_Act))     ptr = new AzpReLayer_Act();   
    else if (s_typ.equals(AzpReLayer_Type_Noop))    ptr = new AzpReLayer_Noop();       
    /*---  for compatibility  ---*/
    else if (s_typ.equals(AzpReLayer_Type_Fc_))     ptr = new AzpReLayer_Fc(); 
    else if (s_typ.equals(AzpReLayer_Type_FcS_))    ptr = new AzpReLayer_FcS(); 
    /*---------------------------*/
    AzX::throw_if_null(ptr, eyec, "null layer ptr.  Wrong type or layer allocation has failed?", s_typ.c_str()); 
    ptr->reset(cset); 
    a.set(index, ptr); 
  }  
};

/*------------------------------------------------------------*/  
class AzpReLayer_Side : public virtual AzpReLayer_ComboH_ {
protected: 
  bool do_vertical; 
  AzpReLayers lays_dflt; 
  AzpReLayers *lays;  /* must not be null anytime */
public:   
  AzpReLayer_Side() : lays(&lays_dflt), do_vertical(false) { s_nm.reset("Side"); }
  virtual ~AzpReLayer_Side() {}                             

  int side_coldstart(const AzOut &_out, const AzpReUpperLayer_ *_upper, AzParam &azp, const AzpReLayer_Param &pp, const AzpCompoSet_ *cset, 
                const AzDataArr<AzBytArr> &as_laytype, const AzDataArr<AzBytArr> &as_layfn);    
  int side_warmstart(const AzOut &_out, const AzpReUpperLayer_ *_upper, AzParam &azp, const AzpReLayer_Param &pp, bool for_testonly); 
                               
  virtual void combo_read(AzFile *file)  { AzX::no_support(true, "AzpReLayer_Side::combo_read", "read"); }
  virtual void combo_write(AzFile *file) const { AzX::no_support(true, "AzpReLayer_Side::combo_write", "write"); }
  virtual void write(AzFile *file) {  /* override */
    writenm(file);
    file->writeBool(do_vertical); 
    file->writeInt(layer_no); 
    lays->write(file); 
  }
  virtual void read(const AzpCompoSet_ *cset, AzFile *file) { 
    readnm(file);
    do_vertical = file->readBool(); 
    layer_no = file->readInt(); 
    lays->read(cset, file);     
  }
  
  virtual void side_upward(bool is_test, const AzDataArr<AzpDataVar_X> &data, AzPmatVar &mv_out);
  virtual void downward(const AzPmatVar &mv_loss_deriv, bool dont_update=false, bool dont_release_sv=false); /* override */
  
  /*---  ---*/
  virtual int coldstart(const AzOut &, const AzpReUpperLayer_ *, AzParam &, const AzpReLayer_Param &, const AzPfx *_pfx=NULL) {
    AzX::no_support(true, "AzpReLayer_Side::coldstart", "common interface"); return -1; 
  }
  virtual int warmstart(const AzOut &,  const AzpReUpperLayer_ *, AzParam &, const AzpReLayer_Param &, 
                        bool, bool do_override_lno=false, const AzPfx *_pfx=NULL) {
    AzX::no_support(true, "AzpReLayer_Side::warmstart", "common interface"); return -1;                       
  }   
  virtual void upward(bool, const AzDataArr<AzpDataVar_X> &, AzPmatVar &, const AzPmatVar *mv2=NULL) { 
    AzX::no_support(true, "AzpReLayer_Side::upward", "common interface"); 
  }
  virtual void upward(bool, const AzPmatVar &, AzPmatVar &, const AzPmatVar *mv2=NULL) { 
    AzX::no_support(true, "AzpReLayer_Side::upward", "common interface");  
  }   
  
protected:   
  void _side_upward_vertical(bool is_test, const AzDataArr<AzpDataVar_X> &data, AzPmatVar &mv_out); 
  void gen_prefix_side(int ix, AzPfx &pfx) const; 
}; 
#endif 
